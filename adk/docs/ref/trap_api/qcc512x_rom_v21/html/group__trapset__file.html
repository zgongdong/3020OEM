<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Trap API: FILE</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Trap API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__trapset__file.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">FILE<div class="ingroups"><a class="el" href="group__api.html">Customer Trap API</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga284247c67005abdb84ac9f13b18e4c27"><td class="memItemLeft" align="right" valign="top">FILE_INDEX&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__file.html#ga284247c67005abdb84ac9f13b18e4c27">FileCreate</a> (const char *name, uint16 length)</td></tr>
<tr class="memdesc:ga284247c67005abdb84ac9f13b18e4c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create file in read-write filesystem.  <a href="#ga284247c67005abdb84ac9f13b18e4c27">More...</a><br /></td></tr>
<tr class="separator:ga284247c67005abdb84ac9f13b18e4c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b796155a06a479f1acba1c118263852"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__file.html#ga2b796155a06a479f1acba1c118263852">FileDelete</a> (FILE_INDEX index)</td></tr>
<tr class="memdesc:ga2b796155a06a479f1acba1c118263852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete file in read-write filesystem.  <a href="#ga2b796155a06a479f1acba1c118263852">More...</a><br /></td></tr>
<tr class="separator:ga2b796155a06a479f1acba1c118263852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c6ee5fa143e456782d2fb8f4930527d"><td class="memItemLeft" align="right" valign="top">FILE_INDEX&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__file.html#ga2c6ee5fa143e456782d2fb8f4930527d">FileFind</a> (FILE_INDEX start, const char *name, uint16 length)</td></tr>
<tr class="memdesc:ga2c6ee5fa143e456782d2fb8f4930527d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the read-only file-system.  <a href="#ga2c6ee5fa143e456782d2fb8f4930527d">More...</a><br /></td></tr>
<tr class="separator:ga2c6ee5fa143e456782d2fb8f4930527d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6641c3f57c3f783dd47905bf0c24f1c2"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__file.html#ga6641c3f57c3f783dd47905bf0c24f1c2">FileMap</a> (FILE_INDEX index, uint32 offset, uint32 size)</td></tr>
<tr class="memdesc:ga6641c3f57c3f783dd47905bf0c24f1c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the address of a file specified by its index Returns the address of a read only mapping of the file specified starting at the given byte offset. The returned address has the same alignment guarantees as the underlying filesystem. As the memory map is different between the customer and firmware processors, this address can only be passed into firmware calls that support it. This is currently restricted to BitSerialTransfer() and BitSerialWrite() as the source data address, and <a class="el" href="group__trapset__crypto.html#ga30964b9602684190cc9d903a7b58bff2" title="Encrypt or decrypt data using the AES128-CTR algorithm. Encrypt and decrypt are identical operations ...">CryptoAes128Ctr()</a>/CryptoAes12Cbc() as the source data. <code>index</code> must be a valid file index in a read only filesystem. Mapping files in a writable filesystem is unsupported. <code>offset</code> must be less than the number of bytes in the file, if it's not the function will return NULL. Attempting to map a file that is 0 bytes long will return NULL. If <code>offset</code> + <code>size</code> extends beyond the length of the file the mapping is truncated to the file boundary. The value #FILE_MAP_SIZE_ALL can be passed to the <code>size</code> argument to indicate that the entire file should be mapped. In ADK6 the <code>size</code> parameter is ignored, the entire file is always made readable, this is an implementation detail of this release and must not be relied on. In addition to invalid arguments, this function will return NULL if the flash layout is such that Apps P1 is unable to access the file via the memory map, or the file is unable to be mapped at this particular time. For a given implementation of this API, it may not be possible for the implementation to prevent file mapping pointers from working after the file has been unmapped. Hence, code that incorrectly uses a pointer to a mapped file after unmapping the file may appear to operate successfully. This behaviour must not be relied on as it may vary from file to file and it is subject to change without notice. If the same file is mapped in multiple times at the same offset then the implementation of this API may return different pointers for each map or it may return the same pointer. In either event, the implementation guarantees that the following code will work:  <a href="#ga6641c3f57c3f783dd47905bf0c24f1c2">More...</a><br /></td></tr>
<tr class="separator:ga6641c3f57c3f783dd47905bf0c24f1c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad344a179505817f4f0d095e7e0fca5db"><td class="memItemLeft" align="right" valign="top">FILE_INDEX&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__file.html#gad344a179505817f4f0d095e7e0fca5db">FileParent</a> (FILE_INDEX item)</td></tr>
<tr class="memdesc:gad344a179505817f4f0d095e7e0fca5db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the index of the directory containing this file or directory.  <a href="#gad344a179505817f4f0d095e7e0fca5db">More...</a><br /></td></tr>
<tr class="separator:gad344a179505817f4f0d095e7e0fca5db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga878e5628291b768883e1ded10557c246"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__file.html#ga878e5628291b768883e1ded10557c246">FileRename</a> (const char *old_path, uint16 old_path_len, const char *new_path, uint16 new_path_len)</td></tr>
<tr class="memdesc:ga878e5628291b768883e1ded10557c246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename file in read-write filesystem.  <a href="#ga878e5628291b768883e1ded10557c246">More...</a><br /></td></tr>
<tr class="separator:ga878e5628291b768883e1ded10557c246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0467a1b122e444b4ff5dec015019201d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__file.html#ga0467a1b122e444b4ff5dec015019201d">FileSystemUnmount</a> (const char *mount_path)</td></tr>
<tr class="memdesc:ga0467a1b122e444b4ff5dec015019201d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmount filesystem Used to free up memory on the system processor when the current file operations have been completed. After this call the file system will be mounted again automatically when any trap referencing it is used (such as FileFind or FileCreate).  <a href="#ga0467a1b122e444b4ff5dec015019201d">More...</a><br /></td></tr>
<tr class="separator:ga0467a1b122e444b4ff5dec015019201d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47a21ef1f814aca7f5252fd500e309f3"><td class="memItemLeft" align="right" valign="top">FILE_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__file.html#ga47a21ef1f814aca7f5252fd500e309f3">FileType</a> (FILE_INDEX index)</td></tr>
<tr class="memdesc:ga47a21ef1f814aca7f5252fd500e309f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the type of a file specified by its index.  <a href="#ga47a21ef1f814aca7f5252fd500e309f3">More...</a><br /></td></tr>
<tr class="separator:ga47a21ef1f814aca7f5252fd500e309f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1590721c71eea35e0543516739ad0bfa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__file.html#ga1590721c71eea35e0543516739ad0bfa">FileUnmap</a> (const void *addr)</td></tr>
<tr class="memdesc:ga1590721c71eea35e0543516739ad0bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release access to the address of a file <code>addr</code> should be a currently mapped address previously returned by <a class="el" href="group__trapset__file.html#ga6641c3f57c3f783dd47905bf0c24f1c2" title="Find the address of a file specified by its index Returns the address of a read only mapping of the f...">FileMap()</a>. If <code>addr</code> is set to NULL, <a class="el" href="group__trapset__file.html#ga1590721c71eea35e0543516739ad0bfa" title="Release access to the address of a file addr should be a currently mapped address previously returned...">FileUnmap()</a> will return TRUE without performing an unmap operation. The implementation may validate that unmap operations are only performed on currently mapped pointers and that they are performed the correct number of times when the same file section has been repeatedly mapped. If invalid usage is detected this function will return FALSE. However, for efficiency, the implementation may decide not do detect some invalid uses.  <a href="#ga1590721c71eea35e0543516739ad0bfa">More...</a><br /></td></tr>
<tr class="separator:ga1590721c71eea35e0543516739ad0bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaeb61907baee930bd5c716815fb9f422"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__file.html#gaaeb61907baee930bd5c716815fb9f422">StreamFileSink</a> (FILE_INDEX index)</td></tr>
<tr class="memdesc:gaaeb61907baee930bd5c716815fb9f422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the file in writable filesystem and return a sink structure to that file.  <a href="#gaaeb61907baee930bd5c716815fb9f422">More...</a><br /></td></tr>
<tr class="separator:gaaeb61907baee930bd5c716815fb9f422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5ffcf73cab931ea251261e6ac93a239"><td class="memItemLeft" align="right" valign="top"><a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__file.html#gae5ffcf73cab931ea251261e6ac93a239">StreamFileSource</a> (FILE_INDEX index)</td></tr>
<tr class="memdesc:gae5ffcf73cab931ea251261e6ac93a239"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a source with the contents of the specified file.  <a href="#gae5ffcf73cab931ea251261e6ac93a239">More...</a><br /></td></tr>
<tr class="separator:gae5ffcf73cab931ea251261e6ac93a239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2b0d32ebff811b8fce25dd83362bc6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__file.html#gaa2b0d32ebff811b8fce25dd83362bc6a">StreamFilesystemSink</a> (FILESYSTEM_ID filesystem_id)</td></tr>
<tr class="memdesc:gaa2b0d32ebff811b8fce25dd83362bc6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a sink for writing an entire filesystem. The entire filesystem must fit into the available space in the stream so that it can be written in a single flush. This is required so that the entire filesystem can be validated before any erase or write operations happen. Once the entire filesystem has been written into this stream SinkFlushBlocking should be called to validate and write the data. SinkFlushBlocking will return false if any stage of the validate / erase / write / initialise process fails. Alternatively, SinkFlush can be used to write the filesystem, but the operation should only be considered successfully complete when MESSAGE_MORE_SPACE is received by the sink's associated task. When using SinkFlush, if any stage of the process fails then, whilst SinkFlush may have returned TRUE, MESSAGE_MORE_SPACE will not be sent to the sink's task. This sink does not support being connected to stream sources, i.e. calling StreamConnect on a Filesystem sink will return 0. This sink is automatically closed when a flush completes successfully. The StreamFilesystemEnable MIB key must be set to 'true' for this trap to be used. This MIB key should be disabled before release as this trap allows anyone with access to the Apps P1 traps to modify the contents of filesystems which may contain sensitive information. Example:  <a href="#gaa2b0d32ebff811b8fce25dd83362bc6a">More...</a><br /></td></tr>
<tr class="separator:gaa2b0d32ebff811b8fce25dd83362bc6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36712d57e68b8867fcfc1b66be31b2c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__file.html#ga36712d57e68b8867fcfc1b66be31b2c2">StreamFilesystemSource</a> (FILESYSTEM_ID filesystem_id)</td></tr>
<tr class="memdesc:ga36712d57e68b8867fcfc1b66be31b2c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a source with the contents of the specified filesystem. The StreamFilesystemEnable MIB key must be set to 'true' for this trap to be used. This MIB key should be disabled before release as this trap allows anyone with access to the Apps P1 traps to read the contents of filesystems which may contain sensitive information. This sink does not support being connected to stream sources, i.e. calling StreamConnect on a Filesystem source will return 0. Example:  <a href="#ga36712d57e68b8867fcfc1b66be31b2c2">More...</a><br /></td></tr>
<tr class="separator:ga36712d57e68b8867fcfc1b66be31b2c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga284247c67005abdb84ac9f13b18e4c27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FILE_INDEX FileCreate </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create file in read-write filesystem. </p>
<dl class="section note"><dt>Note</dt><dd>read-write filesystem does not support directory structure. File path should not contain any extra directory apart from "/rwfs/" which needs to be prepended to the file name.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name (including a path) of the item to create </td></tr>
    <tr><td class="paramname">length</td><td>the number of characters in <em>name</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the file created, or #FILE_NONE if could not.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This trap may NOT be called from a high-priority task handler </dd></dl>

</div>
</div>
<a class="anchor" id="ga2b796155a06a479f1acba1c118263852"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FileDelete </td>
          <td>(</td>
          <td class="paramtype">FILE_INDEX&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete file in read-write filesystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the file which needs to be deleted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success or not.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This trap may NOT be called from a high-priority task handler </dd></dl>

</div>
</div>
<a class="anchor" id="ga2c6ee5fa143e456782d2fb8f4930527d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FILE_INDEX FileFind </td>
          <td>(</td>
          <td class="paramtype">FILE_INDEX&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access to the read-only file-system. </p>
<p>file</p>
<dl class="section see"><dt>See also</dt><dd>#<a class="el" href="group__trapset__file.html#gae5ffcf73cab931ea251261e6ac93a239" title="Return a source with the contents of the specified file. ">StreamFileSource</a>, #<a class="el" href="group__trapset__kalimba.html#ga54936baf35f22f7c3218a0b23b3209f0" title="Control of the Kalimba DSP. ">KalimbaLoad</a> Find the index for a named file or directory, relative to the starting directory.</dd></dl>
<p>Leading and trailing directory separators in <em>name</em> are ignored. <em>start</em> is commonly #FILE_ROOT. </p><dl class="section note"><dt>Note</dt><dd>For file in read-write filesystem start parameter needs to be #FILE_ROOT and path should have "/rwfs/" prepended to the file name. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>index of directory in which to start the search </td></tr>
    <tr><td class="paramname">name</td><td>the name (possibly including a path) of the item to find </td></tr>
    <tr><td class="paramname">length</td><td>the number of characters in <em>name</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the item searched for, or #FILE_NONE if no such item exists.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This trap may NOT be called from a high-priority task handler </dd></dl>

</div>
</div>
<a class="anchor" id="ga6641c3f57c3f783dd47905bf0c24f1c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* FileMap </td>
          <td>(</td>
          <td class="paramtype">FILE_INDEX&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the address of a file specified by its index Returns the address of a read only mapping of the file specified starting at the given byte offset. The returned address has the same alignment guarantees as the underlying filesystem. As the memory map is different between the customer and firmware processors, this address can only be passed into firmware calls that support it. This is currently restricted to BitSerialTransfer() and BitSerialWrite() as the source data address, and <a class="el" href="group__trapset__crypto.html#ga30964b9602684190cc9d903a7b58bff2" title="Encrypt or decrypt data using the AES128-CTR algorithm. Encrypt and decrypt are identical operations ...">CryptoAes128Ctr()</a>/CryptoAes12Cbc() as the source data. <code>index</code> must be a valid file index in a read only filesystem. Mapping files in a writable filesystem is unsupported. <code>offset</code> must be less than the number of bytes in the file, if it's not the function will return NULL. Attempting to map a file that is 0 bytes long will return NULL. If <code>offset</code> + <code>size</code> extends beyond the length of the file the mapping is truncated to the file boundary. The value #FILE_MAP_SIZE_ALL can be passed to the <code>size</code> argument to indicate that the entire file should be mapped. In ADK6 the <code>size</code> parameter is ignored, the entire file is always made readable, this is an implementation detail of this release and must not be relied on. In addition to invalid arguments, this function will return NULL if the flash layout is such that Apps P1 is unable to access the file via the memory map, or the file is unable to be mapped at this particular time. For a given implementation of this API, it may not be possible for the implementation to prevent file mapping pointers from working after the file has been unmapped. Hence, code that incorrectly uses a pointer to a mapped file after unmapping the file may appear to operate successfully. This behaviour must not be relied on as it may vary from file to file and it is subject to change without notice. If the same file is mapped in multiple times at the same offset then the implementation of this API may return different pointers for each map or it may return the same pointer. In either event, the implementation guarantees that the following code will work: </p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;char x;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;const char *ptr1, *ptr2;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;FILE_INDEX ind = (some code to retrieve an index);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;ptr1 = FileMap(ind, 0, 50);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;ptr2 = FileMap(ind, 0, 100);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;FileUnmap(ptr1);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;x = ptr2[99];</div></div><!-- fragment --><p> However, if the <a class="el" href="group__trapset__file.html#ga1590721c71eea35e0543516739ad0bfa" title="Release access to the address of a file addr should be a currently mapped address previously returned...">FileUnmap()</a> call were to pass ptr2 then that code would not be guaranteed to work. It may work coincidentally in a given implementation but this behaviour must not be relied on as it may vary from file to file and is subject to change without notice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the file whose address is required </td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the file in bytes </td></tr>
    <tr><td class="paramname">size</td><td>The size of the file to be addressable in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The address of the file within the application subsystem or NULL on failure</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This trap may NOT be called from a high-priority task handler </dd></dl>

</div>
</div>
<a class="anchor" id="gad344a179505817f4f0d095e7e0fca5db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FILE_INDEX FileParent </td>
          <td>(</td>
          <td class="paramtype">FILE_INDEX&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the index of the directory containing this file or directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The index of the item we know about. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the directory containing item, or #FILE_NONE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This trap may NOT be called from a high-priority task handler </dd></dl>

</div>
</div>
<a class="anchor" id="ga878e5628291b768883e1ded10557c246"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FileRename </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>old_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>old_path_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>new_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>new_path_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rename file in read-write filesystem. </p>
<dl class="section note"><dt>Note</dt><dd>If a file is renamed to itself then it will return FALSE. </dd>
<dd>
For files in read-write filesystem, path needs to have "/rwfs/" prepended to the file names.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_path</td><td>the name (including a path) of the file to rename </td></tr>
    <tr><td class="paramname">old_path_len</td><td>the number of characters in old path name </td></tr>
    <tr><td class="paramname">new_path</td><td>the new name (including a path) of the file </td></tr>
    <tr><td class="paramname">new_path_len</td><td>the number of characters in new path name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success or not.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This trap may NOT be called from a high-priority task handler </dd></dl>

</div>
</div>
<a class="anchor" id="ga0467a1b122e444b4ff5dec015019201d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FileSystemUnmount </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mount_path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unmount filesystem Used to free up memory on the system processor when the current file operations have been completed. After this call the file system will be mounted again automatically when any trap referencing it is used (such as FileFind or FileCreate). </p>
<dl class="section note"><dt>Note</dt><dd>This trap does not support all filesystems. If the given filesystem is not supported then this trap will return FALSE.</dd>
<dd>
For read-write filesystem mount path needs to be "/rwfs/".</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mount_path</td><td>the mount path of the filesystem to unmount </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if unmounted successfully, otherwise FALSE</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This trap may NOT be called from a high-priority task handler </dd></dl>

</div>
</div>
<a class="anchor" id="ga47a21ef1f814aca7f5252fd500e309f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FILE_TYPE FileType </td>
          <td>(</td>
          <td class="paramtype">FILE_INDEX&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the type of a file specified by its index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the file whose type is required </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The type of the specified file.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This trap may NOT be called from a high-priority task handler </dd></dl>

</div>
</div>
<a class="anchor" id="ga1590721c71eea35e0543516739ad0bfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FileUnmap </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release access to the address of a file <code>addr</code> should be a currently mapped address previously returned by <a class="el" href="group__trapset__file.html#ga6641c3f57c3f783dd47905bf0c24f1c2" title="Find the address of a file specified by its index Returns the address of a read only mapping of the f...">FileMap()</a>. If <code>addr</code> is set to NULL, <a class="el" href="group__trapset__file.html#ga1590721c71eea35e0543516739ad0bfa" title="Release access to the address of a file addr should be a currently mapped address previously returned...">FileUnmap()</a> will return TRUE without performing an unmap operation. The implementation may validate that unmap operations are only performed on currently mapped pointers and that they are performed the correct number of times when the same file section has been repeatedly mapped. If invalid usage is detected this function will return FALSE. However, for efficiency, the implementation may decide not do detect some invalid uses. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The mapped address of the file to unmap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the given address was seccessfully unmapped, FALSE on failure.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This trap may NOT be called from a high-priority task handler </dd></dl>

</div>
</div>
<a class="anchor" id="gaaeb61907baee930bd5c716815fb9f422"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> StreamFileSink </td>
          <td>(</td>
          <td class="paramtype">FILE_INDEX&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open the file in writable filesystem and return a sink structure to that file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the name (possibly including a path) of the item to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the file created, or #FILE_NONE if could not.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This trap may NOT be called from a high-priority task handler </dd></dl>

</div>
</div>
<a class="anchor" id="gae5ffcf73cab931ea251261e6ac93a239"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a> StreamFileSource </td>
          <td>(</td>
          <td class="paramtype">FILE_INDEX&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a source with the contents of the specified file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the file whose contents are requested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if index is #FILE_NONE, or does not correspond to a narrow file.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This trap may NOT be called from a high-priority task handler </dd></dl>

</div>
</div>
<a class="anchor" id="gaa2b0d32ebff811b8fce25dd83362bc6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> StreamFilesystemSink </td>
          <td>(</td>
          <td class="paramtype">FILESYSTEM_ID&#160;</td>
          <td class="paramname"><em>filesystem_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a sink for writing an entire filesystem. The entire filesystem must fit into the available space in the stream so that it can be written in a single flush. This is required so that the entire filesystem can be validated before any erase or write operations happen. Once the entire filesystem has been written into this stream SinkFlushBlocking should be called to validate and write the data. SinkFlushBlocking will return false if any stage of the validate / erase / write / initialise process fails. Alternatively, SinkFlush can be used to write the filesystem, but the operation should only be considered successfully complete when MESSAGE_MORE_SPACE is received by the sink's associated task. When using SinkFlush, if any stage of the process fails then, whilst SinkFlush may have returned TRUE, MESSAGE_MORE_SPACE will not be sent to the sink's task. This sink does not support being connected to stream sources, i.e. calling StreamConnect on a Filesystem sink will return 0. This sink is automatically closed when a flush completes successfully. The StreamFilesystemEnable MIB key must be set to 'true' for this trap to be used. This MIB key should be disabled before release as this trap allows anyone with access to the Apps P1 traps to modify the contents of filesystems which may contain sensitive information. Example: </p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;// Create a Filesystem Sink</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;Sink sink = PanicNull(StreamFilesystemSink(FILESYSTEM_ID_DEVICE_RO_FS));</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;uint8 *mapped = SinkMap(sink);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;uint16 total = 0;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;// Copy each packet to the sink before flushing</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;while((data = userDefinedGetPacketFunction(&amp;length)))</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;{</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  uint16 offset = SinkClaim(sink, length);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  memcpy(mapped + offset, data, length);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  total += length;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;}</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;// Blocking flush to validate, erase, write and initialise the filesystem.</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;SinkFlushBlocking(sink, total);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filesystem_id</td><td>The filesystem whose contents are to be written. Currently FILESYSTEM_ID_DEVICE_RO_FS is the only supported value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the provided filesystem_id is not supported or if the StreamFilesystemEnable MIB key is false. A sink for writing to the filesystem otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This trap may NOT be called from a high-priority task handler </dd></dl>

</div>
</div>
<a class="anchor" id="ga36712d57e68b8867fcfc1b66be31b2c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a> StreamFilesystemSource </td>
          <td>(</td>
          <td class="paramtype">FILESYSTEM_ID&#160;</td>
          <td class="paramname"><em>filesystem_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a source with the contents of the specified filesystem. The StreamFilesystemEnable MIB key must be set to 'true' for this trap to be used. This MIB key should be disabled before release as this trap allows anyone with access to the Apps P1 traps to read the contents of filesystems which may contain sensitive information. This sink does not support being connected to stream sources, i.e. calling StreamConnect on a Filesystem source will return 0. Example: </p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;uint16 size;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;Source source = StreamFilesystemSource(FILESYSTEM_ID_DEVICE_RO_FS);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;while ((size = SourceBoundary(source)) != 0)</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;{</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  const uint8 *data = SourceMap(source);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  // do something with the data here</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  SourceDrop(source, size);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;SourceClose(source);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filesystem_id</td><td>The filesystem whose contents are requested. Currently FILESYSTEM_ID_DEVICE_RO_FS is the only supported value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the provided filesystem_id is not supported or if the StreamFilesystemEnable MIB key is false. The contents of the filesystem otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This trap may NOT be called from a high-priority task handler </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
