<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Trap API: BLUESTACK</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Trap API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__trapset__bluestack.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">BLUESTACK<div class="ingroups"><a class="el" href="group__api.html">Customer Trap API</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga10725ea9d3d838056f05bdb533b3986d"><td class="memItemLeft" align="right" valign="top">InquiryPriority&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga10725ea9d3d838056f05bdb533b3986d">InquiryGetPriority</a> (void)</td></tr>
<tr class="memdesc:ga10725ea9d3d838056f05bdb533b3986d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current priority level of Bluetooth inquiry.  <a href="#ga10725ea9d3d838056f05bdb533b3986d">More...</a><br /></td></tr>
<tr class="separator:ga10725ea9d3d838056f05bdb533b3986d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65db1eff3aadbff0b93ea396cc0e81b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga65db1eff3aadbff0b93ea396cc0e81b0">InquirySetPriority</a> (InquiryPriority priority)</td></tr>
<tr class="memdesc:ga65db1eff3aadbff0b93ea396cc0e81b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure Bluetooth inquiry procedure.  <a href="#ga65db1eff3aadbff0b93ea396cc0e81b0">More...</a><br /></td></tr>
<tr class="separator:ga65db1eff3aadbff0b93ea396cc0e81b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95b9d502d69a5d4e42cc3b9334c94b32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga95b9d502d69a5d4e42cc3b9334c94b32">MessageBlueStackTask</a> (<a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a> task)</td></tr>
<tr class="memdesc:ga95b9d502d69a5d4e42cc3b9334c94b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a task to handle BlueStack primitives.  <a href="#ga95b9d502d69a5d4e42cc3b9334c94b32">More...</a><br /></td></tr>
<tr class="separator:ga95b9d502d69a5d4e42cc3b9334c94b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5789ebdfd7814f743c051b45289b58b6"><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga5789ebdfd7814f743c051b45289b58b6">SinkGetL2capCid</a> (<a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> sink)</td></tr>
<tr class="memdesc:ga5789ebdfd7814f743c051b45289b58b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the L2CAP channel id corresponding to a sink.  <a href="#ga5789ebdfd7814f743c051b45289b58b6">More...</a><br /></td></tr>
<tr class="separator:ga5789ebdfd7814f743c051b45289b58b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8993b3833971180e7154a9d8e100832"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#gad8993b3833971180e7154a9d8e100832">SinkPollAwayTime</a> (<a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> sink, uint16 *msec)</td></tr>
<tr class="memdesc:gad8993b3833971180e7154a9d8e100832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the away time on the underlying ACL.  <a href="#gad8993b3833971180e7154a9d8e100832">More...</a><br /></td></tr>
<tr class="separator:gad8993b3833971180e7154a9d8e100832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga382089ef9cc353b61de31b31c47ceae3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga382089ef9cc353b61de31b31c47ceae3">StreamL2capSink</a> (uint16 cid)</td></tr>
<tr class="memdesc:ga382089ef9cc353b61de31b31c47ceae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the Sink corresponding to an L2CAP connection.  <a href="#ga382089ef9cc353b61de31b31c47ceae3">More...</a><br /></td></tr>
<tr class="separator:ga382089ef9cc353b61de31b31c47ceae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e104a1dc884af12dbccd18a608018fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga6e104a1dc884af12dbccd18a608018fa">VmGetBdAddrtFromCid</a> (uint16 cid, <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *tpaddr)</td></tr>
<tr class="memdesc:ga6e104a1dc884af12dbccd18a608018fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrives the <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> value from the given CID value.  <a href="#ga6e104a1dc884af12dbccd18a608018fa">More...</a><br /></td></tr>
<tr class="separator:ga6e104a1dc884af12dbccd18a608018fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac29e1496922249cd04d17dd64558faab"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#gac29e1496922249cd04d17dd64558faab">VmGetHandleFromPointer</a> (void *pointer)</td></tr>
<tr class="memdesc:gac29e1496922249cd04d17dd64558faab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a VM address space pointer to a handle When assembling a primitive which includes indirect blocks, the application must:  <a href="#gac29e1496922249cd04d17dd64558faab">More...</a><br /></td></tr>
<tr class="separator:gac29e1496922249cd04d17dd64558faab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64c8a83677acdc389f0b3454c4ea7b7f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga64c8a83677acdc389f0b3454c4ea7b7f">VmGetLocalIrk</a> (<a class="el" href="structpacked__irk.html">packed_irk</a> *irk)</td></tr>
<tr class="memdesc:ga64c8a83677acdc389f0b3454c4ea7b7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves local IRK (Identity Resolving Key) of the device.  <a href="#ga64c8a83677acdc389f0b3454c4ea7b7f">More...</a><br /></td></tr>
<tr class="separator:ga64c8a83677acdc389f0b3454c4ea7b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5caccd8ae3cfa1246373caffe1d218b7"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga5caccd8ae3cfa1246373caffe1d218b7">VmGetPointerFromHandle</a> (void *handle)</td></tr>
<tr class="memdesc:ga5caccd8ae3cfa1246373caffe1d218b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a handle to a VM address space pointer. If a Bluestack primitive refers to indirect blocks of memory, those are presented in the primitive as handles rather than real pointers. To access the data an application must pass the handle to <a class="el" href="group__trapset__bluestack.html#ga5caccd8ae3cfa1246373caffe1d218b7" title="Converts a handle to a VM address space pointer. If a Bluestack primitive refers to indirect blocks o...">VmGetPointerFromHandle()</a> which will make the indirect block visible to the application. The application must call this exactly once for each such indirect block, and the resulting pointers must all be passed to free. Failure to perform this procedure will result in a resource leak. Note - while <a class="el" href="group__trapset__bluestack.html#gac29e1496922249cd04d17dd64558faab" title="Converts a VM address space pointer to a handle When assembling a primitive which includes indirect b...">VmGetHandleFromPointer()</a> will successfully produce a handle from a pointer to a constant, <a class="el" href="group__trapset__bluestack.html#ga5caccd8ae3cfa1246373caffe1d218b7" title="Converts a handle to a VM address space pointer. If a Bluestack primitive refers to indirect blocks o...">VmGetPointerFromHandle()</a> will not produce a pointer from such a handle. It will instead panic with VM_PANIC_READ_FROM_ILLEGAL_ADDRESS.  <a href="#ga5caccd8ae3cfa1246373caffe1d218b7">More...</a><br /></td></tr>
<tr class="separator:ga5caccd8ae3cfa1246373caffe1d218b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1258d4e01d5cec00dd9a21ae73ed9966"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga1258d4e01d5cec00dd9a21ae73ed9966">VmGetPublicAddress</a> (const <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *random_addr, <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *public_addr)</td></tr>
<tr class="memdesc:ga1258d4e01d5cec00dd9a21ae73ed9966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves public address for a given random address. Note: To be used only on an established link.  <a href="#ga1258d4e01d5cec00dd9a21ae73ed9966">More...</a><br /></td></tr>
<tr class="separator:ga1258d4e01d5cec00dd9a21ae73ed9966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f6a871c7336b62f171fa4302c24e00e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga2f6a871c7336b62f171fa4302c24e00e">VmOverrideL2capConnContext</a> (uint16 cid, <a class="el" href="vm___8h.html#af7048ed13446de52e9012e19b10aebd0">conn_context_t</a> context)</td></tr>
<tr class="memdesc:ga2f6a871c7336b62f171fa4302c24e00e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override L2CAP connecton context.  <a href="#ga2f6a871c7336b62f171fa4302c24e00e">More...</a><br /></td></tr>
<tr class="separator:ga2f6a871c7336b62f171fa4302c24e00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga717489e28b88057dde0c6e96c1137dce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga717489e28b88057dde0c6e96c1137dce">VmOverrideRfcommConnContext</a> (uint16 conn_id, <a class="el" href="vm___8h.html#af7048ed13446de52e9012e19b10aebd0">conn_context_t</a> context)</td></tr>
<tr class="memdesc:ga717489e28b88057dde0c6e96c1137dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override RFCOMM connecton context.  <a href="#ga717489e28b88057dde0c6e96c1137dce">More...</a><br /></td></tr>
<tr class="separator:ga717489e28b88057dde0c6e96c1137dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25d4e01659e990ebc0b77ceb832869c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga25d4e01659e990ebc0b77ceb832869c8">VmOverrideSyncConnContext</a> (uint16 handle, <a class="el" href="vm___8h.html#af7048ed13446de52e9012e19b10aebd0">conn_context_t</a> context)</td></tr>
<tr class="memdesc:ga25d4e01659e990ebc0b77ceb832869c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override DM Sync connecton context.  <a href="#ga25d4e01659e990ebc0b77ceb832869c8">More...</a><br /></td></tr>
<tr class="separator:ga25d4e01659e990ebc0b77ceb832869c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c7349b61ec91e3078739b24c9832f64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga0c7349b61ec91e3078739b24c9832f64">VmSendDmPrim</a> (void *prim)</td></tr>
<tr class="memdesc:ga0c7349b61ec91e3078739b24c9832f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a DM Bluestack primitive.  <a href="#ga0c7349b61ec91e3078739b24c9832f64">More...</a><br /></td></tr>
<tr class="separator:ga0c7349b61ec91e3078739b24c9832f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga623628caf10541c84058d562a909b329"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga623628caf10541c84058d562a909b329">VmSendL2capPrim</a> (void *prim)</td></tr>
<tr class="memdesc:ga623628caf10541c84058d562a909b329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends an L2CAP Bluestack primitive.  <a href="#ga623628caf10541c84058d562a909b329">More...</a><br /></td></tr>
<tr class="separator:ga623628caf10541c84058d562a909b329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b2a62ea647b44972a997650ffb74938"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga1b2a62ea647b44972a997650ffb74938">VmSendSdpPrim</a> (void *prim)</td></tr>
<tr class="memdesc:ga1b2a62ea647b44972a997650ffb74938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends an SDP Bluestack primitive.  <a href="#ga1b2a62ea647b44972a997650ffb74938">More...</a><br /></td></tr>
<tr class="separator:ga1b2a62ea647b44972a997650ffb74938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbaffd14325353278ea2e684f06b14c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#gacbaffd14325353278ea2e684f06b14c1">VmUpdateRootKeys</a> (<a class="el" href="structpacked__root__keys.html">packed_root_keys</a> *root_keys)</td></tr>
<tr class="memdesc:gacbaffd14325353278ea2e684f06b14c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates ER (Encryption Root) and IR (Identity Root) root key values of the device. The local IRK/CSRK/LTK are regenerated as a result of calling this trap.  <a href="#gacbaffd14325353278ea2e684f06b14c1">More...</a><br /></td></tr>
<tr class="separator:gacbaffd14325353278ea2e684f06b14c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga10725ea9d3d838056f05bdb533b3986d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InquiryPriority InquiryGetPriority </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current priority level of Bluetooth inquiry. </p>
<dl class="section return"><dt>Returns</dt><dd>The current priority level.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This trap may NOT be called from a high-priority task handler </dd></dl>

</div>
</div>
<a class="anchor" id="ga65db1eff3aadbff0b93ea396cc0e81b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool InquirySetPriority </td>
          <td>(</td>
          <td class="paramtype">InquiryPriority&#160;</td>
          <td class="paramname"><em>priority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure Bluetooth inquiry procedure. </p>
<p>fileThese functions can be used to change the details of how BlueCore schedules Bluetooth inquiry relative to other Bluetooth activity. They are equivalent to the Inquiry_Priority BCCMD. Sets the priority level of Bluetooth inquiry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priority</td><td>The desired priority level. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the level was successfully set, FALSE otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This trap may NOT be called from a high-priority task handler </dd></dl>

</div>
</div>
<a class="anchor" id="ga95b9d502d69a5d4e42cc3b9334c94b32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a> MessageBlueStackTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a>&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a task to handle BlueStack primitives. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>This task will receive MESSAGE_BLUESTACK_*_PRIM, except #MESSAGE_BLUESTACK_ATT_PRIM that are handled by the <a class="el" href="group__trapset__att.html#gabcdbacb41dd8edf00d78888bbc8469c8" title="Register a task to handle BlueStack ATT primitives. ">MessageAttTask()</a> and #MESSAGE_BLUESTACK_SDM_PRIM that are handled by the <a class="el" href="group__trapset__shadowing.html#ga840a2905a411b868d9023d834ec5b194" title="Register a task to handle BlueStack Shadow Manager(SDM) primitives. ">MessageSdmTask()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old task (or zero).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This trap may be called from a high-priority task handler </dd></dl>

</div>
</div>
<a class="anchor" id="ga5789ebdfd7814f743c051b45289b58b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16 SinkGetL2capCid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td>
          <td class="paramname"><em>sink</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the L2CAP channel id corresponding to a sink. </p>
<dl class="section note"><dt>Note</dt><dd>If the sink is an operator sink stream then it always returns Zero because BlueCore firmware can not get L2CAP channel id from operator sink stream. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sink</td><td>The Sink to get the connection identifier for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This trap may NOT be called from a high-priority task handler </dd></dl>

</div>
</div>
<a class="anchor" id="gad8993b3833971180e7154a9d8e100832"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SinkPollAwayTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td>
          <td class="paramname"><em>sink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16 *&#160;</td>
          <td class="paramname"><em>msec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the away time on the underlying ACL. </p>
<p>The away time is the time since any packet was received on that ACL and is reported in milliseconds. If the time exceeds 0xFFFF, 0xFFFF will be returned (this is unlikely with sensible link supervision timeouts.) </p><dl class="section note"><dt>Note</dt><dd>If the sink is an operator sink stream then it always returns Zero because BlueCore firmware can not get ACL connections from operator sink stream. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sink</td><td>identifies the underlying ACL </td></tr>
    <tr><td class="paramname">msec</td><td>receives the away time if the call succeeds (unmodified otherwise) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the sink identifies an ACL and the away time on that link could be read, FALSE otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This trap may NOT be called from a high-priority task handler </dd></dl>

</div>
</div>
<a class="anchor" id="ga382089ef9cc353b61de31b31c47ceae3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> StreamL2capSink </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>cid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the Sink corresponding to an L2CAP connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cid</td><td>The connection ID to fetch the Sink for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This trap may NOT be called from a high-priority task handler </dd></dl>

</div>
</div>
<a class="anchor" id="ga6e104a1dc884af12dbccd18a608018fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VmGetBdAddrtFromCid </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>cid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *&#160;</td>
          <td class="paramname"><em>tpaddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrives the <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> value from the given CID value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cid</td><td>The connection identifier to fetch the Bluetooth address from. </td></tr>
    <tr><td class="paramname">tpaddr</td><td>If the address is found it will be returned to the location pointed at by this value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if an address was found for a given CID, FALSE otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This trap may NOT be called from a high-priority task handler </dd></dl>

</div>
</div>
<a class="anchor" id="gac29e1496922249cd04d17dd64558faab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* VmGetHandleFromPointer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pointer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a VM address space pointer to a handle When assembling a primitive which includes indirect blocks, the application must: </p>
<ul>
<li>Allocate a block</li>
<li>Convert it to a handle</li>
<li>Store the handle in the primitive rather than storing the pointer itself <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointer</td><td>The pointer to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This trap may NOT be called from a high-priority task handler </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ga64c8a83677acdc389f0b3454c4ea7b7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VmGetLocalIrk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpacked__irk.html">packed_irk</a> *&#160;</td>
          <td class="paramname"><em>irk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves local IRK (Identity Resolving Key) of the device. </p>
<p>The IR (Identity Root) is a root key of the device for the LE Transport and is used to generate the local IRK. The local IRK can be requested only after the initialization of the IR value using "DM_SM_INIT_REQ_T" primitive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">irk</td><td>If IRK information could be read, it will be returned to the location pointed at by this value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if local IRK was retrieved, FALSE otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This trap may NOT be called from a high-priority task handler </dd></dl>

</div>
</div>
<a class="anchor" id="ga5caccd8ae3cfa1246373caffe1d218b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* VmGetPointerFromHandle </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a handle to a VM address space pointer. If a Bluestack primitive refers to indirect blocks of memory, those are presented in the primitive as handles rather than real pointers. To access the data an application must pass the handle to <a class="el" href="group__trapset__bluestack.html#ga5caccd8ae3cfa1246373caffe1d218b7" title="Converts a handle to a VM address space pointer. If a Bluestack primitive refers to indirect blocks o...">VmGetPointerFromHandle()</a> which will make the indirect block visible to the application. The application must call this exactly once for each such indirect block, and the resulting pointers must all be passed to free. Failure to perform this procedure will result in a resource leak. Note - while <a class="el" href="group__trapset__bluestack.html#gac29e1496922249cd04d17dd64558faab" title="Converts a VM address space pointer to a handle When assembling a primitive which includes indirect b...">VmGetHandleFromPointer()</a> will successfully produce a handle from a pointer to a constant, <a class="el" href="group__trapset__bluestack.html#ga5caccd8ae3cfa1246373caffe1d218b7" title="Converts a handle to a VM address space pointer. If a Bluestack primitive refers to indirect blocks o...">VmGetPointerFromHandle()</a> will not produce a pointer from such a handle. It will instead panic with VM_PANIC_READ_FROM_ILLEGAL_ADDRESS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This trap may NOT be called from a high-priority task handler </dd></dl>

</div>
</div>
<a class="anchor" id="ga1258d4e01d5cec00dd9a21ae73ed9966"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VmGetPublicAddress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *&#160;</td>
          <td class="paramname"><em>random_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *&#160;</td>
          <td class="paramname"><em>public_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves public address for a given random address. Note: To be used only on an established link. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">random_addr</td><td>Random address. </td></tr>
    <tr><td class="paramname">public_addr</td><td>If the public address is found it will be returned to the location pointed at by this value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if public address was found for a given resolvable random address, FALSE otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This trap may NOT be called from a high-priority task handler </dd></dl>

</div>
</div>
<a class="anchor" id="ga2f6a871c7336b62f171fa4302c24e00e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VmOverrideL2capConnContext </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>cid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vm___8h.html#af7048ed13446de52e9012e19b10aebd0">conn_context_t</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override L2CAP connecton context. </p>
<p>This trap allows application to override the L2CAP connection context for a given cid. In general, this trap will be used where the L2CAP connection structures in Bluestack is populated as a result of unmarshalling and not because of a L2CAP connection initiation from the application. In such a case connection context in the L2CAP connection structures won't be initialized. So, after unmarshalling, the application needs to explicitly call this trap to initialize the connection context for all the relevant L2CAP connection ids.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cid</td><td>The L2CAP connection id </td></tr>
    <tr><td class="paramname">context</td><td>Connection context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if connection context value is set successfully, FALSE otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This trap may NOT be called from a high-priority task handler </dd></dl>

</div>
</div>
<a class="anchor" id="ga717489e28b88057dde0c6e96c1137dce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VmOverrideRfcommConnContext </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>conn_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vm___8h.html#af7048ed13446de52e9012e19b10aebd0">conn_context_t</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override RFCOMM connecton context. </p>
<p>This trap allows application to override the RFCOMM connection context for a given RFCOMM connection id. In general, this trap will be used where the RFCOMM connection structures in Bluestack is populated as a result of unmarshalling and not because of a RFCOMM client connection initiation from the application. In such a case connection context in the RFCOMM connection structures won't be initialized. So, after unmarshalling, the application needs to explicitly call this trap to initialize the connection context for all the relevant RFCOMM connection ids.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn_id</td><td>The RFCOMM connection id </td></tr>
    <tr><td class="paramname">context</td><td>Connection context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if connection context value is set successfully, FALSE otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This trap may NOT be called from a high-priority task handler </dd></dl>

</div>
</div>
<a class="anchor" id="ga25d4e01659e990ebc0b77ceb832869c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VmOverrideSyncConnContext </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vm___8h.html#af7048ed13446de52e9012e19b10aebd0">conn_context_t</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override DM Sync connecton context. </p>
<p>This trap allows application to override the DM Sync connection context for a given eSCO connection handle. In general, this trap will be used where the DM Sync connection structures in Bluestack is populated as a result of unmarshalling and not because of a DM Sync connection initiation from the application. In such a case connection context in the DM Sync connection structures won't be initialized. So, after unmarshalling, the application needs to explicitly call this trap to initialize the connection context for all the relevant eSCO connection handles.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The eSCO connection handle </td></tr>
    <tr><td class="paramname">context</td><td>Connection context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if connection context value is set successfully, FALSE otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This trap may NOT be called from a high-priority task handler </dd></dl>

</div>
</div>
<a class="anchor" id="ga0c7349b61ec91e3078739b24c9832f64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VmSendDmPrim </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>prim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a DM Bluestack primitive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prim</td><td>A pointer to the primitive to send. The memory must have been dynamically allocated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This trap may be called from a high-priority task handler </dd></dl>

</div>
</div>
<a class="anchor" id="ga623628caf10541c84058d562a909b329"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VmSendL2capPrim </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>prim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends an L2CAP Bluestack primitive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prim</td><td>A pointer to the primitive to send. The memory must have been dynamically allocated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This trap may be called from a high-priority task handler </dd></dl>

</div>
</div>
<a class="anchor" id="ga1b2a62ea647b44972a997650ffb74938"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VmSendSdpPrim </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>prim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends an SDP Bluestack primitive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prim</td><td>A pointer to the primitive to send. The memory must have been dynamically allocated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This trap may be called from a high-priority task handler </dd></dl>

</div>
</div>
<a class="anchor" id="gacbaffd14325353278ea2e684f06b14c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VmUpdateRootKeys </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpacked__root__keys.html">packed_root_keys</a> *&#160;</td>
          <td class="paramname"><em>root_keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates ER (Encryption Root) and IR (Identity Root) root key values of the device. The local IRK/CSRK/LTK are regenerated as a result of calling this trap. </p>
<p>The root keys comprise IR and ER keys. These are used to generate IRK, CSRK and Legacy LTK. This trap is normally used if a device wants to synchronize its root keys with a device with which it would share a common Bluetooth address. This trap doesn't update the root keys in the persistent store, so the change is not persistent. Note: The application needs to make sure that it should not call this trap when the device is advertising or scanning using a resolvable private address. Moreover, if the device has a pre-existing LE SC (secure connections) pairing with other remote devices and this trap is called then the new ER value will not affect the bonding state for those devices. If the device has a legacy pairing with remote devices, then overwriting the ER value will invalidate the bonding state for those remote devices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_keys</td><td>New ER and IR values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if IR and ER values were set successfully, FALSE otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This trap may NOT be called from a high-priority task handler </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
